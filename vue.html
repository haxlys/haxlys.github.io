<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>02-03</title>
	<script src="https://unpkg.com/vue/dist/vue.min.js"></script>
</head>
<style>
	html, body {
		height: 100%;
		overflow: hidden;
	}
  pre {
    font-family: initial;
    margin: initial;
  }
	.center {
		text-align: center;
	}
	#leftSideContainer {
		width: 20%;
		height: 100%;
		min-width: 100px;
		max-width: 200px;
    	float: left;
	}
  #template {
    display: none;
  }
  .flex-container {
    display: -webkit-flex;
    display: flex;
    flex-direction: row;
    justify-content: center;
    flex-wrap: wrap;
  }
  .flex-item {
    margin: 10px 0;
  }
  .flex-item.title {
    width: 30%;
  }
  .flex-item.desc {
    width: 60%;
    text-align: left;
  }
</style>
<body>
	<h1 class="center">Vue.js</h1>
	<div id="leftSideContainer">
		<h5>기초</h5>
		<ul>
			<li v-for="(menu, key) in menus" v-on:click="contentChange(key)">{{ menu.name }}</li>
		</ul>
  </div>
  
	<div id="mainContentContainer"></div>

  <div id="template">
    <div id="Directive" class="flex-container">
      <div class="flex-item title">v-text: v-html: </div>
      <div class="flex-item desc">DOM 요소의 컨텐츠를 변경한다.</div>

      <div class="flex-item title">v-bind: </div>
      <div class="flex-item desc">DOM 요소의 속성을 변경한다.<br/>
      약어로 : 를 사용한다.</div>

      <div class="flex-item title">v-show: v-:if v-else v-else-if</div>
      <div class="flex-item desc">Vue data 속성에 따라 렌더링 여부를 결정하는 기능<br/>
        show와 if의 차이는 렌더링의 여부<br/>
        show는 렌더링 하되 조건에 따라서 display:none을 갖는다.<br/>
        자주 판정된다면 show를 사용해서 리플로우 리페인트를 피하는게 좋다.
      </div>

      <div class="flex-item title">v-for: </div>
      <div class="flex-item desc">반복 렌더링 기능 <br/>
        v-for="(value, index) in array" <br/>
        v-for="(value, key, index) in object" <br/>
        v-if 보다 v-for가 더 우선순위가 높아서 for 실행 후 if 판정이 실행된다.<br/>
        &lt;template v-for="">&lt;/template> 를 이용해서 직접 DOM 요소에 for를 적용하지 않고 사용할 수도 있다.<br/>
        &lt;template v-for="value in list" v-bind:key="value.primaryKey">&lt;/template>
        Vue는 for로 렌더할 때 렌더되는 DOM 요소에 key 속성을 data의 키값으로 바인딩 시키는 것을 권장한다. for로 렌더된 DOM의 data가 변경될 경우 DOM을 조작하거나 다시 그리지 않고 data만 변경시키기 때문이다.
        이는 속도면에서 유리하다.
      </div>

      <div class="flex-item title">v-pre: </div>
      <div class="flex-item desc">컴파일을 수행하지 않음</div>

      <div class="flex-item title">v-once: </div>
      <div class="flex-item desc">컴파일을 한번만 수행<br/>
        자식 요소들도 영향을 받음
      </div>

      <div class="flex-item title">v-cloak: </div>
      <div class="flex-item desc">컴파일 되지 않은 템플릿을 나타나지 않도록 해줌<br/>
        일시적으로 보이는 콧수염 표현식을 해결해줌
      </div>
      
    </div>

    <div id="VueInstance" class="flex-container">
      <div class="flex-item title">data</div>
      <div class="flex-item desc">프록시를 이용해서 처리<br/> vm.$data.name과 같이 접근 가능</div>
      
      <div class="flex-item title">el</div>
      <div class="flex-item desc"><pre>Vue 인스턴스에 연결할 HTML DOM요소를 지정
여러 요소를 지정할 수 없음
class로 여러개 지정할 수 없으며 첫번째 요소만 지정됨</pre>
      </div>
      
      <div class="flex-item title">computed</div>
      <div class="flex-item desc" v-pre>
        <pre>계산형 속성으로 미리 선계산됨
게터 세터 적용가능
data: {
  cnt: 0,
}
computed: {
  count: {
    get: function () {
      return this.cnt + "개";
    },
    set: function (cnt) {
      this.cnt = ++cnt;
    }
  }
}
        </pre>
      </div>

      
      
      <div class="flex-item title">methods</div>
      <div class="flex-item desc" v-pre>
      
      </div>

    </div>
  </div>

	<script type="text/javascript">
    var leftMenuModel = {
          test: '123',
          menus: [],
        },
        div = document.querySelectorAll("#template>div")

    div.forEach(function (one) {
      leftMenuModel.menus.push({
        name: one.id,
        renderedVm: new (Vue.extend({ template: document.querySelector("#" + one.id).outerHTML, }))().$mount(),
      });
    })

    var leftSideContainer = new Vue({
      el: '#leftSideContainer',
      data: leftMenuModel,
      created: function () {
        this.contentChange(1)
      },
      methods: {
        contentChange: function (idx) {
          document.querySelector('#mainContentContainer').innerHTML = ''
          document.querySelector('#mainContentContainer').appendChild(this.menus[idx].renderedVm.$el)
        }
      }
    })

	</script>
</body>

</html>