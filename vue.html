<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>I love Vue</title>
	<script src="https://unpkg.com/vue/dist/vue.min.js"></script>
</head>
<style>
	html, body {
		height: 100%;
	}
  pre {
    font-family: initial;
    margin: initial;
  }
	.center {
		text-align: center;
	}
	#leftSideContainer {
		width: 20%;
		height: 100%;
		min-width: 100px;
		max-width: 200px;
    	float: left;
	}
  #template {
    display: none;
  }
  .flex-container {
    display: -webkit-flex;
    display: flex;
    flex-direction: row;
    justify-content: center;
    flex-wrap: wrap;
  }
  .flex-item {
    margin: 10px 0;
  }
  .flex-item.title {
    width: 30%;
  }
  .flex-item.desc {
    width: 60%;
    text-align: left;
  }
  .list-title {
    width: 100%;
    list-style: none;
    text-align: center;
    color: crimson;
    font-weight: bold;
  }
</style>
<body>
	<h1 class="center">Vue.js</h1>
	<div id="leftSideContainer">
		<h5>기초</h5>
		<ul>
			<li v-for="(menu, key) in menus" v-on:click="contentChange(key)">{{ menu.name }}</li>
		</ul>
  </div>
  
	<div id="mainContentContainer"></div>

  <div id="template">
    <div id="Directive">
      <h3 class="center">DOM 요소들을 렌더하는데 도움을 주는 지시어</h3>
      <div class="flex-container">
      
        <div class="flex-item title">v-text: v-html: </div>
        <div class="flex-item desc">DOM 요소의 컨텐츠를 변경한다.</div>

        <div class="flex-item title">v-bind: </div>
        <div class="flex-item desc">DOM 요소의 속성을 변경한다.<br/>
        약어로 : 를 사용한다.</div>

        <div class="flex-item title">v-show: v-:if v-else v-else-if</div>
        <div class="flex-item desc">Vue data 속성에 따라 렌더링 여부를 결정하는 기능<br/>
          show와 if의 차이는 렌더링의 여부<br/>
          show는 렌더링 하되 조건에 따라서 display:none을 갖는다.<br/>
          자주 판정된다면 show를 사용해서 리플로우 리페인트를 피하는게 좋다.
        </div>

        <div class="flex-item title">v-for: </div>
        <div class="flex-item desc">반복 렌더링 기능 <br/>
          v-for="(value, index) in array" <br/>
          v-for="(value, key, index) in object" <br/>
          v-if 보다 v-for가 더 우선순위가 높아서 for 실행 후 if 판정이 실행된다.<br/>
          &lt;template v-for="">&lt;/template> 를 이용해서 직접 DOM 요소에 for를 적용하지 않고 사용할 수도 있다.<br/>
          &lt;template v-for="value in list" v-bind:key="value.primaryKey">&lt;/template>
          Vue는 for로 렌더할 때 렌더되는 DOM 요소에 key 속성을 data의 키값으로 바인딩 시키는 것을 권장한다. for로 렌더된 DOM의 data가 변경될 경우 DOM을 조작하거나 다시 그리지 않고 data만 변경시키기 때문이다.
          이는 속도면에서 유리하다.
        </div>

        <div class="flex-item title">v-pre: </div>
        <div class="flex-item desc">컴파일을 수행하지 않음</div>

        <div class="flex-item title">v-once: </div>
        <div class="flex-item desc">컴파일을 한번만 수행<br/>
          자식 요소들도 영향을 받음
        </div>

        <div class="flex-item title">v-cloak: </div>
        <div class="flex-item desc">컴파일 되지 않은 템플릿을 나타나지 않도록 해줌<br/>
          일시적으로 보이는 콧수염 표현식을 해결해줌
        </div>
      </div>
    </div>

    <div id="VueInstance">
      <h3 class="center">Vue 인스턴스 옵션들</h3>
      <div class="flex-container">
        <div class="flex-item title">data</div>
        <div class="flex-item desc">프록시를 이용해서 처리<br/> vm.$data.name과 같이 접근 가능</div>
        
        <div class="flex-item title">el</div>
        <div class="flex-item desc"><pre>Vue 인스턴스에 연결할 HTML DOM요소를 지정
  여러 요소를 지정할 수 없음
  class로 여러개 지정할 수 없으며 첫번째 요소만 지정됨</pre>
        </div>
        
        <div class="flex-item title">computed</div>
        <div class="flex-item desc" v-pre>
          <pre>계산된 속성으로 미리 선계산됨
  계산되어졌다는 computed 과거형에 주목해야함.
  함수의 실행이 아닌 이미 실행된 함수의 return 값에 접근하는 것과 같다.
  의존하고 있는 속성값이 변경되면 다시 평가(실행)된다.
  게터 세터 적용가능
  data: {
    cnt: 0,
  }
  computed: {
    count: {
      get: function () {
        return this.cnt + "개";
      },
      set: function (cnt) {
        this.cnt = ++cnt;
      }
    }
  }
          </pre>
        </div>
        
        <div class="flex-item title">methods</div>
        <div class="flex-item desc" v-pre>
        vue 인스턴스, 디렉티브 표현식, 콧수열 표현식 사용할 수 있다.
        화살표 함수를 사용해서는 안된다.
        화살표 함수에서 this는 Vue 인스턴스가 아닌 전역 객체를 가리키기 때문이다.
        따라서 내부 데이터에 접근할 수 없다.
        </div>
        
        <div class="flex-item title">watch</div>
        <div class="flex-item desc" v-pre>
        Vue data의 속성 이름을 함수의 watch 함수의 이름으로 등록하면 해당 data 값이 변경될 때마다 함수가 실행되어진다.
        함수는 변경된 값을 인자로 받는다.
        watch는 속성 하나에 대한 변경값을 감시한다면
        computed는 의존하는 모든 속성에 대한 변경값을 감시한다.
        watch는 값을 리턴하지 않아도 될 때, 즉 비동기 처리에 적합
        computed는 리턴된 값을 사용해야 할 경우, 즉 동기 처리에 적합
        </div>
      </div>
    </div>

    <div id="Hook">
      <h3 class="center">라이프 사이클 중간 중간 실행할 수 있는 Hook</h3>
      <div @click="image = !image">이미지 보기</div>
      <img v-show="image" src="./images/vueLifeCycle.jpg" alt="라이프사이클" width="800px">
      <div class="flex-container">
        <div class="flex-item title">beforeCreate</div>
        <div class="flex-item desc" v-pre>Vue 인스턴스가 생성되고 데이터에 대한 관찰 기능 및 이벤트 감시자 설정 전에 호출</div>
        
        <div class="flex-item title">create</div>
        <div class="flex-item desc" v-pre>Vue 인스턴스가 생선된 후 데이터에 대한 관찰 기능, 계산형 속성, 메서드, 감시자 설정이 완료된 후에 호출</div>
        
        <div class="flex-item title">beforeMount</div>
        <div class="flex-item desc" v-pre>마운트가 시작되기 전에 호출</div>
        
        <div class="flex-item title">mounted</div>
        <div class="flex-item desc" v-pre>el에 vue 인스턴스의 데이터가 마운트된 후 호출</div>
        
        <div class="flex-item title">beforeUpdate</div>
        <div class="flex-item desc" v-pre>가상 DOM이 렌더링, 패치되기 전 데이터가 변경될 때 호출. 추가적인 상태 변경을 수행할 수 있으나 추가로 렌더링을 하지 않는다.</div>
        
        <div class="flex-item title">updated</div>
        <div class="flex-item desc" v-pre>데이터 변경으로 가상 DOM이 다시 렌더링 되고 패치된 후 호출. 이 훅이 호출되었을 때는 이미 컴포넌트의 DOM이 업데이트된 상태. 그래서 DOM이 종속성이 있는 연산을 이 단계에서 수행할 수 있다.</div>
        
        <div class="flex-item title">beforeDestroy</div>
        <div class="flex-item desc" v-pre>Vue 인스턴스가 제거되기 전 호출</div>
        
        <div class="flex-item title">destroyed</div>
        <div class="flex-item desc" v-pre>Vue 인스턴스가 제거된 후에 호출됩니다. 이 훅이 호출될 때는 Vue 인스턴스의 모든 디렉티브의 바인딩이 해제되고 이벤트 연결도 모두 제거됩니다.</div>
      </div>
    </div>
    
    <div id="Event">
      <h3 class="center">라이프 사이클 중간 중간 실행할 수 있는 Hook</h3>
      <div class="flex-container">
        <div class="flex-item title">v-on:</div>
        <div class="flex-item desc" v-pre>이벤트 디렉티브이며 약어는 @: 로 사용가능</div>
        
        <div class="flex-item title">이벤트 객체</div>
        <div class="flex-item desc" v-pre>
          <ul class="flex-container">
            <li class="list-title">이벤트 객체의 주요 속성</li>

            <li class="flex-item title">target</li>
            <li class="flex-item desc">이벤트가 발생한 HTML 요소를 리턴함</li>
            <li class="flex-item title">currentTarget</li>
            <li class="flex-item desc">이벤트리스너가 이벤트를 발생시키는 HTML 요소를 리턴</li>
            <li class="flex-item title">path</li>
            <li class="flex-item desc">배열값, 이벤트 발생 HTML 요소로부터 document, window 객체로까지 거슬러 올라가는 경로를 나타냄</li>
            <li class="flex-item title">bubbles</li>
            <li class="flex-item desc">현재의 이벤트가 버블링을 일으키는 이벤트인지 여부를 리턴함</li>
            <li class="flex-item title">cancleable</li>
            <li class="flex-item desc">기본 이벤트를 방지할 수 있는지 여부를 리턴함</li>
            <li class="flex-item title">defaultPrevented</li>
            <li class="flex-item desc">기본 이벤트가 방지되었는지 여부를 나타냄</li>
            <li class="flex-item title">eventPhase</li>
            <li class="flex-item desc">이벤트 흐름 단계를 나타냄
              <ol>
                <li>포착(CAPTURING_PHASE)</li>
                <li>이벤트 발생(AT_TARGET)</li>
                <li>버블링(BUBLING_PHASE)</li>
              </ol>
            </li>
            <li class="flex-item title">srcElement</li>
            <li class="flex-item desc">IE에서 사용되던 속성으로 target과 동일한 속성</li>
          </ul>
        
          <ul class="flex-container">
            <li class="list-title">키보드 이벤트 관련 속성</li>

            <li class="flex-item title">altKey</li>
            <li class="flex-item desc">altKey 키 토글 여부를 나타냄(true/false)</li>
            <li class="flex-item title">shiftKey</li>
            <li class="flex-item desc">shiftKey 키 토글 여부를 나타냄(true/false)</li>
            <li class="flex-item title">ctrlKey</li>
            <li class="flex-item desc">ctrlKey 키 토글 여부를 나타냄(true/false)</li>
            <li class="flex-item title">metaKey</li>
            <li class="flex-item desc">Windows OS 에서는 window 키, Mac OS 에서는 Command 키 토글 여부를 나타냄(true/false)</li>
            <li class="flex-item title">key</li>
            <li class="flex-item desc">이벤트에 의해 나타나는 키의 값을 리턴함. 대소문자 구분함.</li>
            <li class="flex-item title">code</li>
            <li class="flex-item desc">이벤트를 발생시킨 키의 코드값을 리턴함.
              ex) a를 눌렀을 때 "KeyA"를 리턴함
              ex) shfit를 눌렀을 때 "Shift"를 리턴함
            </li>
            <li class="flex-item title">charCode</li>
            <li class="flex-item desc">keypress 이벤트가 발생될 때 Unicode 캐릭터 코드를 리턴함</li>
            <li class="flex-item title">location</li>
            <li class="flex-item desc">디바이스에서의 키 위칫값. 일반 키보드는 이 값이 모두 0이므로 이용할 수 없음</li>
          </ul>

          <ul class="flex-container">
            <li class="list-title">마우스 이벤트 관련 속성</li>

            <li class="flex-item title">altKey, shiftKey, ctrlKey, metaKey</li>
            <li class="flex-item desc">키보드와 동일</li>
            <li class="flex-item title">button</li>
            <li class="flex-item desc">이벤트를 발생시킨 마우스 버튼
              <ol>
                <li>0: 마우스 왼쪽 버튼</li>
                <li>1: 마우스 휠</li>
                <li>2: 마우스 오른쪽 버튼</li>
              </ol>
            </li>
            <li class="flex-item title">buttons</li>
            <li class="flex-item desc">
              마우스 이벤트가 발생한 후에 눌러져 있는 마우스 버튼의 값을 리턴함, 아래 값의 조합으로 이루어짐
              <ol>
                <li>1: 마우스 왼쪽 버튼</li>
                <li>2: 마우스 오른쪽 버튼</li>
                <li>4: 마우스 휠</li>
                <li>8: 4번째 마우스 버튼</li>
                <li>16: 5번째 마우스 버튼</li>
              </ol>
              ex) 마우스의 오른쪽 버튼, 휠을 누르고 있는 상태에서 왼쪽 버튼을 클릭할 경우 이 값은 6(2+4)을 리턴함.
            </li>
            <li class="flex-item title">clientX, clientY</li>
            <li class="flex-item desc">마우스 이벤트가 일어났을 때의 뷰포트(ViewPort) 영역상의 좌표, 이 좌표는 스크롤바를 내리더라도 좌푯값에 영향을 받지 않음</li>
            <li class="flex-item title">layerX, layerY</li>
            <li class="flex-item desc">마우스 이벤트가 발생한 HTML 요소 영역상에서의 좌표(IE이외의 브라우저에서 사용)</li>
            <li class="flex-item title">offsetX, offsetY</li>
            <li class="flex-item desc">마우스 이벤트가 발생한 HTML 요소 영역상에서의 좌표(IE 브라우저에서 사용)</li>            </li>
            <li class="flex-item title">pageX, pageY</li>
            <li class="flex-item desc">마우스 이벤트가 발생했을 때 HTML 문서(Document) 영역상의 좌표</li>
            <li class="flex-item title">screeX, screenY</li>
            <li class="flex-item desc">마우스 이벤트가 발생했을 때 모니터 영역상의 좌표</li>
          </ul>
        </div>

        <div class="flex-item title">DOM 요소의 기본 이벤트</div>
        <div class="flex-item desc" v-pre>a 같은 요소는 클릭할 경우 내장되어 있는 기본 이벤트가 호출된다.
          <ul>
            대표적인 기본 이벤트
            <li>a</li>
            <li>오른쪽 버튼의 컨텍스트 메뉴 ContextMenu</li>
            <li>form 요소 내부의 submit 버튼</li>
            <li>input type=text 요소에 키보드를 누르면 입력한 문자가 텍스트 박스에 나타나는 기능</li>
          </ul>
        </div>

        <div class="flex-item title">기본 이벤트를 중지시키는 방법</div>
        <div class="flex-item desc" v-pre>v-on:EVENT.prevent="method"</div>

        <div class="flex-item title">이벤트 전파(버블링, 캡처링) 중지시키는 방법</div>
        <div class="flex-item desc" v-pre>
          <ul>
            <li>v-on:EVENT.stop="method" 이벤트 전파를 중지</li>
            <li>v-on:EVENT.capture="method" CAPTURING_PHASE 단계에서만 이벤트 발생</li>
            <li>v-on:EVENT.self="method" RAISING_PHASE 단계에서만 이벤트 발생</li>
          </ul>
        </div>

        <div class="flex-item title">once : 이벤트를 단 한번만 실행</div>
        <div class="flex-item desc" v-pre>v-on:EVENT.once="method"</div>

        <div class="flex-item title">keyup : 키보드 키코드를 이용한 메서드 실행</div>
        <div class="flex-item desc" v-pre>
          <ul>
            <li> @keyup="method" method: function (e) { if(e.keyCode === 13) alert('hi') } </li>
            <li> @keyup.13="method" method: function (e) { alert('hi') } </li>
            <li> @keyup.enter="method" method: function (e) { alert('hi') } </li>
            <li> 제공해주는 쉬운 별칭 : enter, tab delete, exc, space, up down left right ctrl alt shift meta</li>
            <li> @keyup.ctrl.67="copy" Ctrl + C</li>
            <li> 마우스 버튼 수식어: left, right, middle</li>
          </ul>
        </div>
      </div>
    </div>

    <div id="Style">
      <div class="flex-container">
        <div class="flex-item title">인라인 스타일</div>
        <div class="flex-item desc" v-pre><pre>
되도록이면 인라인은 지양한다.
표기법은 javascript 변수명에 - 대쉬를 사용하지 못하기 때문에 카멜법을 사용
data: {
  style: { backgourndColor: 'red' }
}
&lt;div v-bind:style="style" @mouseover.stop="method1" @mouseout.stop="method2">

개별 속성으로 지정할 수도 있다.(추천안함)
data: {
  a: { bc: 'red' }
}
:style="{ backgroundColor: a.bc }"

배열 방식도 가능
v-bind:style="[myColor,myLayout]
data : {
  myColor : { backgroundColor:'purple', color:'yellow' },
  myLayout : { width:'150px', height:'80px', textAlign:'center' }
}
          </pre>
        </div>

        <div class="flex-item title">Class 바인딩</div>
        <div class="flex-item desc" v-pre><pre>
v-bind:class="{ class명: boolean, ... }"
.set1 { background-color: aqua; color:purple; }
.set2 { text-align:center; width:120px; }
.set3 { border:sandybrown dashed 1px; }
data : { s1 : false, s2 : false, s3 : false }
&lt;button id="btn1" v-bind:class="{ set1:s1, set2:s2, set3:s3 }">버튼1&lt;/button>
더 직관적인 방법
mystyle : { set1:false, set2:false, set3:false }
&lt;button id="btn1" v-bind:class="mystyle">버튼1&lt;/button>
        </pre></div>

        <div class="flex-item title">계산형 속성,<br/>메서드를 이용한 스타일 적용</div>
        <div class="flex-item desc" v-pre><pre>
스타일 .warning { background-color: orange; color:purple; }
DOM v-bind:class="info"
computed
  info : function() {
    ...
    return { warning:false }
  }
        </pre></div>
      </div>
    </div>

    <div id="Component">
      <div class="flex-container">
        <div class="flex-item title">컴포넌트 작성</div>
        <div class="flex-item desc" v-pre><pre>Vue.component(tagname, options)
tagname: 컴포넌트를 사용할 태그명
options: 컴포넌트에서 렌더링할 templet등을 지정
태그명은 가능하다면 케밥 표기명으로 지정하는게 좋다.

&lt;script type="text/javascript">
  Vue.component('hello-component', {
    template: '&lt;div>hello world!!!&lt;/div>'
  })
&lt;/script>
위의 컴포넌트 사용법을 아래와 같이 분리 시킬수 있다.

template 태그 사용
&lt;template id="helloTemplate">
  &lt;div>hello world!!!&lt;/div>
&lt;/template>
&lt;script type="text/javascript">
  Vue.component('hello-component', {
    template: '#helloTemplate'
  })
&lt;/script>

script 태그 사용
&lt;script type="text/x-template" id="helloTemplate">
  &lt;div>hello world!!!&lt;/div>
&lt;/script>
&lt;script type="text/javascript">
  Vue.component('hello-component', {
    template: '#helloTemplate'
  })
&lt;/script>
</pre>
        </div>

        <div class="flex-item title">
          컴포넌트 작성시 주의 사항 1.</div>
        <div class="flex-item desc" v-pre>
<pre>아래와 같이 body 태그안의 dom 요소가 vue 컴포넌트가 아닌 html 요소(select) 중간에 끼어있다면 종종 렌더링되지 않는 현상을 경험할 수 있다.
&lt;script type="text/javascript">
Vue.component('option-component', {
  template: '&lt;option>hello&lt;/option>'
})
&lt;/script>
&lt;body>
  &lt;div id="app">
    &lt;select>
      &lt;option-component>&lt;/option-component>
      &lt;option-component>&lt;/option-component>
    &lt;/select>
  &lt;/div>
&lt;/body>
&lt;script type="text/javascript">
  var v = new Vue({
    el: '#app'
  })
&lt;/script>

해결책: select 태그를 포함한 요소들을 script text/x-template 태그로 감싸줘서 컴포넌트화 시킨다.
여기서 주의할 점은 &lt;template> 태그로 할 경우 위와 같이 렌더되지 않으므로 x-template로 사용해야 한다.
또 다른 방법으로 단일 파일 컴포넌트 형식을 사용한다.
&lt;script type="text/javascript">
  Vue.component('option-component', {
    template: '&lt;option>hello&lt;/option>'
  })
&lt;/script>
&lt;script type="text/x-template" id="selectTemplate">
  &lt;select>
      &lt;option-component>&lt;/option-component>
      &lt;option-component>&lt;/option-component>
   &lt;/select>
&lt;/script>
&lt;script type="text/javascript">
  Vue.component('select-component', {
    template: '#selectTemplate'
  })
&lt;/script>
&lt;body>
  &lt;div id="app">
    &lt;select-component>&lt;/select-component>
  &lt;/div>
&lt;/body>

또 다른 방법으로 is 속성을 사용한다.
&lt;option is='option-component'>&lt;/option>
&lt;option is='option-component'>&lt;/option>
          </pre>
        </div>
        <div class="flex-item title">컴포넌트 작성시 주의 사항 2.</div>
        <div class="flex-item desc" v-pre><pre>
template 문자열 안에서 루트 요소는 하나여야 한다.
Vue.component('option-component', {
  template: '&lt;option>hello&lt;/option>&lt;option>hello&lt;/option>'
})
위와 같이 2개 이상의 root 요소가 있어서는 안된다.
          </pre>
        </div>

        <div class="flex-item title">컴포넌트에서의 data 옵션</div>
        <div class="flex-item desc" v-pre><pre>
컴포넌트에서 data 속성을 정의할 경우 function을 사용해서 return 값으로 data를 설정해야 한다.
component마다 서로 다른 data를 유지해야 하기 때문이다.
data: function () {
  return {
    name: 'jone'
  }
}
          </pre>
        </div>

        <div class="flex-item title">props</div>
        <div class="flex-item desc" v-pre><pre>
&lt;template id="listTemplate">
  &lt;li>{{message}}&lt;/li>
&lt;/template>
&lt;script type="text/javascript">
  Vue.component('list-component', {
    template: '#listTemplate',
    props: ['myMessage']
  })
&lt;/script>
&lt;body>
  &lt;div id="app">
    &lt;ul>
      &lt;list-component my-message="Hello">&lt;/list-component>
      &lt;list-component my-message="씬짜오">&lt;/list-component>
      &lt;list-component my-message="니하오마">&lt;/list-component>
    &lt;/ul>
  &lt;/div>
&lt;/body>

위의 예제를 보면 컴포넌트의 옵션에 props가 보일텐데 
배열에 등록된 문자열이 키값이 되어 컴포넌트 태그의 속성으로 값이 할당된다.
data를 등록하는 것과 같다.

컴포넌트 태그의 속성명을 정할 때 주의사항
html 태그는 대소문자를 가리지 않기때문에 kebob-casing을 사용해야한다.
컴포넌트 props에서는 camelCasing으로 표기한다.

props 검증
props값을 단순히 받기만 한다면 배열형태를 취하고 있어도 되지만
검증을 하고 싶다면 객체형태로 만들고 값을 검증할 수 있다.
props: {
  message: { type: String, default: '안녕하세요' },
}

props 검증시 주의할 점
값이 배열이 객체일 경우 default 속성 사용시 꼭 함수의 return값으로 기본값을 설정해줘야 한다.
배열과 객체는 참조이기 때문에 값을 새로 할당하지 않으면 부모와 자식이 같은 데이터를 참조하기 때문이다.

props로 값 전달시 숫자로 전달하기(props에 data 값을 전달하기)
태그 속성으로 props 값을 전달할 때 숫자만 적으면 컴포넌트는 값을 문자열로 인식한다.
이러한 문제를 해결하기 위해서 v-bind를 사용한다.
&lt;comp :count="100">&lt;/comp>
만약 v-bind에 문자열을 넣어준다면 변수명으로 인식하기 때문에
문자열에 해당하는 data가 할당되어 있어야 한다.
&lt;comp :count="name">&lt;/comp>
data: {
  name: '백만'
}
          </pre>
        </div>
        
        <div class="flex-item title">event</div>
        <div class="flex-item desc" v-pre><pre>
child Component
methods : {
    clickEvent : function(e) {
        this.$emit('timeclick', e.target.innerText, e.target.dataset.lang);
    }
}

parent Component
&lt;child-component v-for="s in buttons" v-bind:button-info="s"  v-on:timeclick="timeclickEvent">&lt;/child-component>
 :
methods : {
    timeclickEvent : function(k, v) {
        this.msg = k + ", " +v;
    }
}

1. 부모 컴포넌트는 자식 태그에 v-on 디렉티브로 자식 컴포넌트의 수신 받을 메소드를 지정한다.
v-on:timeclick="timeclickEvent"
v-on:자식이 호출할 발신명="수신할 본인 객체의 methods"
2. 자식 컴포넌트는 특정 이벤트에 this.$emit()을 통해서 부모에게 내용을 발신한다.
첫번째 인자는 부모가 자식컴포넌트를 만들때 정의했던 v-on 디렉티브의 이름(발신명)
두번째 인자부터 부모로 전달한 데이터를 작성해주면된다.
3. 자식이 발신한(this.$emit()) 부모의 method가 데이터를 받아서 처리하게 된다.
          </pre>
        </div>
        
        <div class="flex-item title">이벤트 버스 객체를 이용한 통신</div>
        <div class="flex-item desc" v-pre><pre>
부모 자식 관계는 props와 event를 이용하면 된다.
하지만 형제 관계에 있는 컴포넌트들끼리 정보를 전달하려면?

비어 있는 Vue 인스턴스를 만들어 사용하면 된다.
데이터를 저장할 필요가 있다면 데이터 옵션을 추가한다.
단지 UI를 만들기 위한 template가 없는 인스턴스이다.

이벤트 버스 객체
var eventBus = new Vue();

첫번째 자식 컴포넌트
methods : {
    clickEvent : function() {
        var d = new Date();
        var t = d.toLocaleTimeString() + " " + d.getMilliseconds() + "ms";
        eventBus.$emit('click1', t);
        this.currentTime = t;
    }
}

두번째 자식 컴포넌트
created : function() {
    eventBus.$on('click1', this.child1Click);
},
methods : {
    child1Click : function(time) {
        this.timelist.push(time);
    }
}

1. vue 인스턴스 생성
2. created로 이벤트 수신 설정($on)을 해준다.(발신 전 미리 수신상태여야 하기 때문에 created 훅에서 수신 설정)
3. 이벤트 발신 설정($emit)을 해준다.
          </pre>
        </div>
      </div>
    </div>

  </div>

	<script type="text/javascript">
    var leftMenuModel = {
          test: '123',
          menus: [],
        },
        div = document.querySelectorAll("#template>div")

    div.forEach(function (one) {
      leftMenuModel.menus.push({
        name: one.id,
        renderedVm: new (Vue.extend({ 
          template: document.querySelector("#" + one.id).outerHTML, 
          data: function() {
            return {
              image:false,
            }
          }
        }))().$mount(),
      });
    })

    var leftSideContainer = new Vue({
      el: '#leftSideContainer',
      data: leftMenuModel,
      created: function () {
        this.contentChange(5)
      },
      computed: {
        test1: function () { alert();
          this.test = this.test;

        }
      },
      methods: {
        contentChange: function (idx) {
          document.querySelector('#mainContentContainer').innerHTML = ''
          document.querySelector('#mainContentContainer').appendChild(this.menus[idx].renderedVm.$el)
        }
      }
    })

	</script>
</body>

</html>